---
date: 2021-03-01
layout: post
title: 再谈谈 mysql 连接池（基于 pymysql 的实际例子）
thread: 2021-03-01_python_mysql_pool_2.md
categories: 数据库
tags: python
---

## 前言

在开发中, 只要涉及到类似 TCP 长连接资源的, 通常都要考虑到使用连接池封装来提高资源的可复用率, 避免频繁建立连接带来的网络请求开销.
在没有使用连接池的时候, client 想执行一条 Mysql update 语句, 先要与 Mysql 进行 3 次网络传输("握手")建立一个 TCP 连接, 然后再发送 1 次命令,
接收 1 次命令执行结果. 如果使用了连接池, 虽然第一次执行上述过程也需要经历 3 次握手, 但是第二次, 第三次等等就省略了这个握手过程.

另外, 使用连接池, 除了可以减少网络交互的时间消耗, 更重要的是 TCP 连接数是有限制的. 当你的服务要面临短时间高并发请求的时候(比如突刺流量), 连接数很容易超出限制抛出错误.

- Mysql 最大连接数限制: `show variables like '%max_connections%';`
- 服务器文件描述符数量限制: `ulimit -n`
  
题外话, 模拟测试的朋友还要注意本地临时端口的限制. TCP 客户端连接服务端的时候，需要获取本地的临时端口，传输层协议限制了最多只有 65535 个端口, 不少都预先占用了.

- 可用的临时端口范围
  - 查看: `cat /proc/sys/net/ipv4/ip_local_port_range`
  - 修改: `echo "start-number  end-number"` ，start-number 和 end-number 是 0-65536 端口号范围内的数，,0-1024 最好不要用，通常是熟知端口，如果是专门的代理服务器的话，很多熟知端口没有使用，当然可以考虑！
    

## 连接池的核心需求

- 存储一定数量的连接
- 线程安全 (支持协程的情况下要保障协程安全)
- 线程阻塞唤醒机制 (基于锁实现的条件变量, 支持线程的阻塞 wait, 和唤醒 notify_all) 


## 池的常用数据结构

- 队列 queue/deque/channel
- 链表 LinkedList
- 数组 array/slice
- 集合 set

以上是一些常见的作为连接池的数据结构, 不管是比较底层的数据结构, 还是封装了的高级数据结构, 最终都是要实现一个 `队列` 的功能, 满足 `连接池的核心需求`.

如果你使用的编程语言是 Golang, 可以使用 channel 作为队列, 协程安全, golang runtime 会自动处理 channel 上阻塞的协程以及唤醒. (底层是 gopark goready 调用, golang 中条件变量的实现同理)
如果你使用的编程语言是 Python, 可以使用 queue (基于 deque 封装), 线程安全, 使用条件变量支持线程的阻塞和唤醒.
如果你使用的编程语言标准库没有 `队列` 的数据结构, 可以基于现有的数据结构实现一个类似的队列, 或者通过第三方库满足功能.




















